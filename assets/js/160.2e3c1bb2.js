(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{942:function(_,v,t){"use strict";t.r(v);var r=t(36),a=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-作用域是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-作用域是什么"}},[_._v("#")]),_._v(" 1.作用域是什么")]),_._v(" "),t("h3",{attrs:{id:"_1-1-编译原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-编译原理"}},[_._v("#")]),_._v(" 1.1 编译原理")]),_._v(" "),t("p",[_._v("JavaScript 归类为“动态”或“解释执行”语言")]),_._v(" "),t("p",[_._v("它不是提前编译的，编译结果也不能在分布式系统中进行移植。")]),_._v(" "),t("h4",{attrs:{id:"_1-分词-词法分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-分词-词法分析"}},[_._v("#")]),_._v(" 1.分词/词法分析")]),_._v(" "),t("p",[t("strong",[_._v("分词（tokenizing）")]),_._v("：字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。")]),_._v(" "),t("p",[_._v("var a = 2;分解成为下面这些词法单元：var、a、=、2 、;")]),_._v(" "),t("p",[t("strong",[_._v("词法分析")]),_._v("（Lexing）： 词法单元生成器在判断 a 是一个独立的词法单元还是其他词法 单元的一部分时，调用的是有状态的解析规则。")]),_._v(" "),t("h4",{attrs:{id:"_2-解析-语法分析（parsing）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解析-语法分析（parsing）"}},[_._v("#")]),_._v(" 2.解析/语法分析（Parsing）")]),_._v(" "),t("p",[_._v("**抽象语法树（Abstract Syntax Tree，AST）**将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。")]),_._v(" "),t("h4",{attrs:{id:"_3-代码生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-代码生成"}},[_._v("#")]),_._v(" 3.代码生成")]),_._v(" "),t("p",[_._v("**代码生成：**AST 转换为可执行代码的过程")]),_._v(" "),t("p",[_._v("创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。")]),_._v(" "),t("p",[_._v("简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此 JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。")]),_._v(" "),t("h3",{attrs:{id:"_1-2-理解作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-理解作用域"}},[_._v("#")]),_._v(" 1.2 理解作用域")]),_._v(" "),t("p",[t("strong",[_._v("引擎")]),_._v("  JavaScript 程序的编译及执行过程。")]),_._v(" "),t("p",[t("strong",[_._v("编译器")]),_._v(" 负责语法分析及代码生成")]),_._v(" "),t("p",[t("strong",[_._v("作用域")]),_._v(" 收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。")]),_._v(" "),t("p",[_._v("变量的赋值操作会执行两个动作，首先"),t("strong",[_._v("编译器")]),_._v("会在当前"),t("u",[_._v("作用域")]),_._v("中"),t("strong",[_._v("声明一个变量")]),_._v("（如 果之前没有声明过），然后在运行时"),t("strong",[_._v("引擎")]),_._v("会在"),t("u",[_._v("作用域")]),_._v("中"),t("strong",[_._v("查找该变量")]),_._v("，如果能够找到就会对它赋值。")]),_._v(" "),t("p",[_._v("当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。")]),_._v(" "),t("p",[_._v("RHS "),t("strong",[_._v("找值")])]),_._v(" "),t("p",[_._v("LHS "),t("strong",[_._v("赋值")])]),_._v(" "),t("h3",{attrs:{id:"_1-3-作用域嵌套"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-作用域嵌套"}},[_._v("#")]),_._v(" 1.3 作用域嵌套")]),_._v(" "),t("p",[_._v("当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套")]),_._v(" "),t("p",[_._v("引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。")]),_._v(" "),t("h3",{attrs:{id:"_1-4-异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-异常"}},[_._v("#")]),_._v(" 1.4 异常")]),_._v(" "),t("p",[_._v("RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛ReferenceError 异常。")]),_._v(" "),t("p",[_._v("ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的")]),_._v(" "),t("p",[_._v("不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。")]),_._v(" "),t("h3",{attrs:{id:"_1-5-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-小结"}},[_._v("#")]),_._v(" 1.5 小结")]),_._v(" "),t("p",[_._v("作用域是一套"),t("strong",[_._v("规则")]),_._v("，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。")]),_._v(" "),t("p",[_._v("to be continued->(立个flag,10月前看完吧)")])])}),[],!1,null,null,null);v.default=a.exports}}]);